.. _L2_2D_FFT_BENCHMARK_LABEL:
.. _Vitis Libraries: https://github.com/Xilinx/Vitis_Libraries
.. _Vitis Library: https://github.com/Xilinx/Vitis_Libraries
.. _DSP Library: https://github.com/Xilinx/Vitis_Libraries/tree/master/dsp
.. _U250: https://www.xilinx.com/products/boards-and-kits/alveo/u250.html
.. _Nimbix: https://www.nimbix.net/
.. _U280: https://www.xilinx.com/products/boards-and-kits/alveo/u280.html
.. _U200: https://www.xilinx.com/products/boards-and-kits/alveo/u200.html
.. _CUDA V10: https://developer.nvidia.com/cuda-10.0-download-archive
.. _cuFFT: https://developer.nvidia.com/cufft
.. _Google Cloud: https://cloud.google.com/

.. toctree::
   :caption: Table of Contents
   :maxdepth: 4
   
   L2_fft_benchmark.rst

========================================
L2 FFT Kernel Benchmarks
========================================

Overview
========================================

L2 FFT benchmarking is done for floating point single precision and fixed point numbers. ALVEO `U250`_ FPGA  is used on `Nimbix`_ cloud. The Vitis 19.2 and XRT 19.2 are used for building overlays for FPGA and host application respectively. Different size of 1D/2D FFT kernels are benchmarked for performance ranging from 256 to 4096 sample for 1D and 16x16 to 256x256 matrices for 2D. All the kernels are described in C++ and built using Vitis 19.2 released version, no RTL component or RTL IP is used for building the kernel.

Benchmarking and Performance Measurements
================================================================

The benchmarking is done on `Nimbix`_ cloud instance which houses a Xilinx Alveo `U250`_ FPGA Acceleration card. Following sections describe benchmarking procedure, measurement process and the performance results.

List of Benchmarks
----------------------------------------------------------------

To the run the benchmarks user has to checkin the Xilinx `Vitis libraries`_. Go to ``dsp/L2/benchmarks/FPGA`` folder which contains the Vitis FFT benchmarks. This folder contains different benchmarks for 1D and 2D FFTs as shown below:

- 1dFix   : 1D Fix Point FFT Benchmark
- 1dFloat : 1D Floating Point FFT Benchmark
- 2dFix	  : 2D Fix Point FFT Benchmark
- 2dFloat : 2D Floating Point FFT Benchmark

Building and Running the Benchmarks
--------------------------------------------------------------------

Before building the host executable or the xclbin FPGA overlay file please source your local setup scripts for setting paths for XRT and Vitis ( If you are running these benchmarks on `Nimbix`_ cloud, starting terminal automatically setups XRT and Vitis).

Configuring FFT Kernel
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Every benchmark is pre-configured with a specific size and data-path for given kernel and to run a benchmark it is not required to change the these configurations. The results reported in the next section for different size of 1D/2D FFT are generated by varying these configurations. Every variation of FFT kernel size requires re-building of host and the xclbin. The section-xxx describes the details of how to configure these different parameters for running benchmarks.

Building Host Executable
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

To run a benchmark navigate to any of the benchmarks for 1D/2D FFT with fix point or floating point data type as needed. Every benchmark has a Makefile which can be used to build host executable namely ``host``. Following command will build a host executable called ``host``.

``make host``

Building xclbin File for FPGA Card
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

The xclbin overlay file for benchmark can be built using the following command:

``make build TARGET=hw DEVICE=../../../xilinx_u250_xdma_201830_2.xpfm``

The above command will build the xclbin in directory whose name starts with build_dir.hw.
During benchmarking the ``xilinx_u250_xdma_201830_2.xpfm`` shell was used. But the benchmark can also be built and ran on other cards like `U200`_, `U280`_ etc.

Running the Benchmark
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Once the host executable and xclbin files are built, benchmark run can be launched as follows:
**If you have built 1D FFT kernel floating or fixed point** use the following command to run the benchmark:

``./host fft1dkernel.xclbin numOfBatches benchamrk_results_file_name.csv``

The arguments passed to host executable are:

- **fft1dkernel.xclbin**: xclbin file name that will be found in build folder whose name starts with build_dir.hw. You should pass relative path to this file
- **numOfBatches**: This is number of batches of data that benchmark generates and passes to FFT kernel for processing
- **benchamrk_results_file_name**: This is the output csv file that will contain the benchmark results.

**If you have built 2D FFT kernel floating or fixed point** use the following command to launch the benchmark:

``./host fft2dkernel.xclbin numOfBatches benchamrk_results_file_name.csv``

The arguments passed to host executable are:

- **fft2dkernel.xclbin**: xclbin file name that will be found in build folder whose name starts with build_dir.hw. You should pass relative path to this file
- **numOfBatches**: This is number of batches of data that benchmark generates and passes to FFT kernel for processing
- **benchamrk_results_file_name**: This is the output csv file that will contain the benchmark results.

NOTE: The makefile provided with the benchmark also supports software emulation and hardware emulation runs which can be be launched as follows:

``make check TARGET=sw_emu DEVICE=../../xilinx_u250_xdma_201830_2.xpfm NUM_OF_BATCHES=numBatches PERF_LOGFILE=perf.csv``

``make check TARGET=sw_emu DEVICE=../../xilinx_u250_xdma_201830_2.xpfm NUM_OF_BATCHES=numBatches PERF_LOGFILE=perf.csv``

**NOTE: The performance log file reported benchmark results are not correct in software or hardware emulation modes.**

Benchmark Results Log File
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
The benchmark result log file provides number of different measurements which include:

- Kernel only execution time
- End to End execution time which includes host to device and device to host data movement time
- Data copy time between host and device
- Bandwidth utilization between host and the device and vice/versa
- Performance in terms of GFLOPs kernel only and the end to end

Detailed Instructions for Running The Benchmarks on Nimbix
----------------------------------------------------------------------

1. Clone git repo: ``git clone https://github.com/Xilinx/Vitis_Libraries.git``
2. Navigate to any benchmark in benchmarks directory in **repo_path/dsp/L2/benchmarks/FPGA/** i.e. ``cd repo_path/dsp/L2/benchmark/FPGA/1dFloat``
3. Source the scripts for setting up the Xilinx XRT and Vitis paths as per your local setup on `Nimbix`_ these scripts are sourced automatically while launching the terminal.
4. Build host executable: ``make host``
5. Build xclbin for FPGA: ``make build TARGET=hw DEVICE=../../../xilinx_u250_xdma_201830_2.xpfm``
6. Launching benchmark : ``./host path_to_xclbin numOfBatches perf_result_file_name.csv``

Benchmarking Results
---------------------------------------------------------------
Next few sections report the benchmark result for four different FFT types, 1D Fixed, 1D Float, 2D Fix and 2D Float.

1D Floating Point(FP32) FFT Benchmark Results
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Floating Point or single precision FFT is benchmarked for different number of batches sizes. The host machine configuration is given below in the table:

.. csv-table:: Host Machine Configuration
   :file: ../csv_data_files/host_conf_bench.csv
   :stub-columns: 1
   :align: left
The performance results are reported in the following table which give performance in terms of FLOPs/execution time for different number of FFT points/sizes. The SSR factor is a low level FFT kernel parameters that tells how many samples kernel can process once they are on-chip. Changing this parameter redefines the kernel performance in terms of maximum frequency at which kernel can run and FPGA resources consumed. SSR factor is also the radix of FFT algorithm used for implementation.

.. csv-table:: 1D Floating Point FFT Benchmark Results
   :file: ../csv_data_files/fft_l2_fp32_bench.csv
   :align: left
   :header-rows: 1

**NOTE: The execution time measurements include data movement times between host and device**

1D Fixed Point(27-bits) FFT Benchmark Results
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Fixed point 27-bit FFT is benchmarked for different number of batches sizes. The host machine configuration is given below in the table:

.. csv-table:: Host Machine Configuration
   :file: ../csv_data_files/host_conf_bench.csv
   :stub-columns: 1
   :align: left

The fixed point data-path configuration for FFT is given below in the table.

.. csv-table:: Fixed Point Data-path configuration
   :file: ../csv_data_files/fft_datapath_config.csv
   :widths: auto
   :align: left

The performance results are reported in the following table which give performance in terms of FLOPs/execution time for different number of FFT points/sizes. The SSR factor reported in the table is a low level FFT kernel parameters that tells how many samples kernel can process once they are on-chip. Changing this parameter redefines the kernel performance in terms of maximum frequency at which kernel can run and FPGA resources consumed. SSR factor is also the radix of FFT algorithm used for implementation.

.. csv-table:: 1D Fixed Point 27 Bits FFT Benchmark Results
   :file: ../csv_data_files/fft_l2_fixed_bench.csv
   :align: left
   :header-rows: 1

**NOTE: The execution time measurements include data movement times between host and device**


2D Floating Point(FP32) FFT Benchmark Results
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Floating Point or single precision 2D FFT is benchmarked for different number of batches sizes. The host machine configuration is given below in the table:

.. csv-table:: Host Machine Configuration
   :file: ../csv_data_files/host_conf_bench.csv
   :stub-columns: 1
   :align: left
The performance results are reported in the following table which give performance in terms of FLOPs/execution time for different number of FFT points/sizes. 2D FFT deploys multiple 1-D FFT kernel running concurrently to process rows and columns of data. The SSR factor is a low level 1D FFT kernel parameters that tells how many samples kernel can process once they are on-chip. Changing this parameter redefines the kernel performance in terms of maximum frequency at which kernel can run and FPGA resources consumed. SSR factor is also the radix of 1D FFT algorithm used for implementation.

.. csv-table:: 2D Floating Point FFT Benchmark Results
   :file: ../csv_data_files/fft2d_l2_fp32_bench.csv
   :align: left
   :header-rows: 1

**NOTE: The execution time measurements include data movement times between host and device**

2D Fixed Point(27 Bits) FFT Benchmark Results
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Fixed point 27 bits 2D FFT is benchmarked for different number of batches sizes. The host machine configuration is given below in the table:

.. csv-table:: Host Machine Configuration
   :file: ../csv_data_files/host_conf_bench.csv
   :stub-columns: 1
   :align: left

The fixed point data-path configuration for 1D FFT Kernels used for row and column processing are given in the table below:

.. csv-table:: Fixed Point Data-path configuration
   :file: ../csv_data_files/fft_datapath_config.csv
   :widths: auto
   :align: left   

The performance results are reported in the following table which give performance in terms of FLOPs/execution time for different number of FFT points/sizes. 2D FFT deploys multiple 1-D FFT kernel running concurrently to process rows and columns of data. The SSR factor is a low level 1D FFT kernel parameters that tells how many samples kernel can process once they are on-chip. Changing this parameter redefines the kernel performance in terms of maximum frequency at which kernel can run and FPGA resources consumed. SSR factor is also the radix of 1D FFT algorithm used for implementation.

.. csv-table:: 2D Fixed Point 27 Bits FFT Benchmark Results
   :file: ../csv_data_files/fft2d_l2_fixed_bench.csv
   :align: left
   :header-rows: 1

**NOTE: The execution time measurements include data movement times between host and device**


Benchmarking Measurement Process and Performance Metrics
----------------------------------------------------------------
All the measurements are taken from host side using high resolution software timers. Specifically ``high_resolution_clock`` class is used for taking and storing time samples. The class provides functionality and storage for high resolution time samples. The following code snippet shows how kernel execution time measurement is taken:

.. code-block:: cpp

	#include <chrono>
	high_resolution_clock::time_point texec_start;
	high_resolution_clock::time_point texec_end;
	OCL_CHECK(err, cl::CommandQueue q(context, device, CL_QUEUE_PROFILING_ENABLE, &err));

	texec_start = high_resolution_clock::now();
	OCL_CHECK(err, err = q.enqueueMigrateMemObjects({buffer_in1}, 0 /* 0 means from host*/));
	OCL_CHECK(err, err = q.enqueueTask(krnl_fft2d));

	OCL_CHECK(err, err = q.enqueueMigrateMemObjects({buffer_in2}, CL_MIGRATE_MEM_OBJECT_HOST));
	OCL_CHECK(err, err = q.finish());
	texec_end = high_resolution_clock::now();
	duration<double> total_exec_span = duration_cast<duration<double> >(texec_end - texec_start);
	double total_exec_time = total_exec_span.count();

``high_resolution_clock::now`` returns a time point that is stored after taking this sample input buffer, 2D FFT kernels and output buffers are queued. After queuing the kernel and memory object movements ``q.finish()`` is called to sync the completion operation and an other time point is sampled and stored. The difference of these two time points gives the execution time including data movement and the kernel computations. Following formulas are used for calculating the FLOPs for 1D and 2D FFTs with complex input and output.

.. csv-table::  FLOPS Calculation Formulas ( FFT Complex In:Complex Out)
   :file: ../csv_data_files/flop_formulas.csv
   :align: left
   :header-rows: 1

Manually Configuring Kernel Parameters
================================================================

1D FFT Kernel Parameter Configurations
------------------------------------------------------------------------------
Kernel parameters can be configured for provided benchmarks to have different:

 - Size of FFT kernel
 - Fix point data path(only for fix point case)
 - Super Sample Rate (SSR) also the radix of FFT algorithm

The fixed point data_path is defined in the source file name ``src/hls_ssr_fft_params.hpp`` , the data-path configuration are controlled by the struct called ''ssr_fft_params''. How these configuration effect the data path and how they should be set for particular FFT application is described in documentation of :ref:`1-D Vitis FFT <L1_FFT_LABEL>`.

The Size of FFT Kernel can be changed by changing the compile time constant in source file called ``src/fft_size.hpp`` namely ``SSR_FFT_L``. The allowed size for 1D FFT are integer power of 2 within range 16:16384. 

The Super Sample Rate or factor can be any number from the set {2,4,8,16}. The value of super sample rate is defined in source file ``src/fft_size.hpp``  as ``SSR_FFT_R``. Changing super sample rate required deeper understanding of benchmark and may have and adverse effect on performance. The best suited SSR factor is 8. The value of 8 is chosen to maximize the bandwidth utilization provided by the wide memory interface(512 Bits) between FPGA kernels and the device memory on Alveo FPGAS cards like `U200`_ `U250`_ and `U280`_. If user understands the memory interface on target boards then he should be able to optimally choose SSR value. 

2D FFT Kernel Parameter Configurations
------------------------------------------------------------------------------
Different parameters of 2D FFT kernels that can be configured include:

- The size of FFT
- The super sample rate (radix of algorithm used carrying out 1D FFTs)
- The data-path of the FFT kernel ( for fix point case only)
- Parameters of input fixed point type ( selection of integer part and fraction part part)

2D FFT Kernel is composed of multiple 1D FFT kernels and different other blocks which perform data ordering transformation. The choices made for parameters of 2D FFT will define how many kernel of 1D FFT type to use how to interconnect them for creating 2D transform.
For any benchmark for 2D FFT, the size of the 1D kernel is defined in source file named ``src/fft_size.hpp`` as ``SSR_FFT_L`` and the super sample rate factor is defined as ``SSR_FFT_R`` in the same file. Given the SSR_FFT_L is defined as some value ``M`` the 2D FFT kernel size of will be ``M x M``. Hence it will process a matrix or image of size ``M x M``.

The input fixed point type is defined in the file called ``src/dtypes_inner.hpp`` as ``ap_fixed`` user can change this type as needed. The values larger then 27 bits may have adverse effect on resource consumption on FPGA.
The super sample rate can be changed the best suitable values is 8 but lower values are also allowed. In the case of 2D FFT the architecture is such that if a value lower than 8 is chosen more number of 1D kernel will be used to maximize the bandwidth utilization of device DDR memory on host. In the case of using lower value of SSR many increase the clock frequency at which kernel can run. 

The fixed point parameter are define in source file named ``src/hls_ssr_fft_params.hpp`` by two different structures namely ``FFTParams`` and ``FFTParams2`` one structure defined the parameters for 1D FFT kernel used along the rows of 2D FFT and other defines the parameters for 1D kernel used along the columns. The configuration can be done as described in the previous section and further detailed information can be found in documentation for :ref:`1-D Vitis FFT <L1_FFT_LABEL>` and :ref:`2-D Vitis FFT <L1_2DFFT_LABEL>`


FFT Benchmarking on GPU
========================================
To compare the performance of Vitis FFT L2 Kernels with GPU performance we have benchmarked the performance of FFT implementation provided by Nvidia as part of `CUDA V10`_. The library is called `cuFFT`_. We have used `Google Cloud`_ which houses a Tesla V100 GPU. The GPU benchmark that we have used is also provided as part of the repo. The following sections describe how to run this benchmark and measure performance.

Building and Running the GPU Benchmark
==============================================================================
The benchmark is provided as part of repo to run the benchmark follow the steps described below. Before this you need to make sure `CUDA V10`_ is installed and available GPU is ready to use with runtime and libraries as needed.
The host machine used for benchmark had the following configurations

.. csv-table:: Host Machine Configuration
   :file: ../csv_data_files/host_gpu_bench.csv
   :stub-columns: 1
   :align: left

1D cuFFT Benchmark
--------------------------------
1. Clone Xilinx Vitis Libraries : ``git clone https://github.com/Xilinx/Vitis_Libraries.git``
2. Navigate to GPU benchmarks   : ``cd REPO_PATH/dsp/L2/benchmarks/GPU/``
3. For 1D FFT Navigate to folder called 1dFFT ``cd 1dFFT``
4. Build host executable : ``make``
5. Launch host executable to run benchmarking: ``./1dFFT``

After the host executable finished the benchmarking process it will create a 1dFFT_benchmark_results.csv data file that will contain benchmark results. The benchmark results will include:

- No. of Batches for given test
- Execution time for given test
- The GLFOPS calculated

1D cuFFT Benchmark Options
----------------------------------------
Host executable provides different options while launching benchmark. These options can be used to control what different range of FFTs are benchmarked and also it has options to specify which range of batch sizes to benchmark. The user can also choose if the linear batch size range is used or logarithmic range with options to control the step size. Following example will explain the usage of benchmarking while launching the executable.

1. ``./1dFFT`` 
   
   - Batch Size range will be **logarithmic**, it will run the benchmark with fixed FFT size range, step size and batch sizes.

2. ``./1dFFT linear``

   - Batch size range will be **linear**, it will run the benchmark with fixed FFT size range, step size and batch sizes.

3. ``./1dFFT max_fft_size max_batch_size``

   - Batch size range will be **logarithmic**, it will run the benchmark with fixed starting FFT size and up to **max_fft_size**, and batch sizes up to **max_batch_size**.   

4. ``./1dFFT linear max_fft_size max_batch_size``

   - Batch size range will be **linear**, it will run the benchmark with fixed starting FFT size up to **max_fft_size**, and batch sizes up to **max_batch_size**.

5. ``./1dFFT starting_fft_size max_fft_size starting_batch_size max_batch_size``

   - Batch size range will be **logarithmic**, it will run the benchmark with starting FFT size **starting_fft_size** and maximum size up to **max_fft_size**, with starting batch size **starting_batch_size** and maximum batch size up to **max_batch_size**

6. ``./1dFFT linear starting_fft_size max_fft_size starting_batch_size max_batch_size``

   - Batch size range will be **linear**, it will run the benchmark with starting FFT size **starting_fft_size** and maximum size up to **max_fft_size**, with starting batch size **starting_batch_size** and maximum batch size up to **max_batch_size**     

7. ``./1dFFT starting_fft_size max_fft_size fft_size_step starting_batch_size max_batch_size batch_size_step``

   - Batch size range will be **logarithmic**, it will run the benchmark with starting FFT size **starting_fft_size** and maximum size up to **max_fft_size** the step on FFT size with be **fft_size_step**, with starting batch size **starting_batch_size** and maximum batch size up to **max_batch_size** and with step on FFT batch size **batch_size_step**      

8. ``./1dFFT linear starting_fft_size max_fft_size fft_size_step starting_batch_size max_batch_size batch_size_step``

   - Batch size range will be **linear**, it will run the benchmark with starting FFT size **starting_fft_size** and maximum size up to **max_fft_size** the step on FFT size with be **fft_size_step**, with starting batch size **starting_batch_size** and maximum batch size up to **max_batch_size** and with step on FFT batch size **batch_size_step**


1D cuFFT Benchmark Results
---------------------------------------

Following table gives performance resutls for 1D FFT benchmarked using cuFFT library for floating point single precision numbers for various lengths and batch sizes. 

.. csv-table:: 2D cuFFT Benchmark Results for Tesla V100 on Google Cloud
   :file: ../csv_data_files/gpu_bench_1dfft.csv
   :align: left
   :header-rows: 1


2D cuFFT Benchmark
--------------------------------
1. Clone Xilinx Vitis Libraries : ``git clone https://github.com/Xilinx/Vitis_Libraries.git``
2. Navigate to GPU benchmarks   : ``cd REPO_PATH/dsp/L2/benchmarks/GPU/``
3. For 2D FFT Navigate to folder called 2dFFT ``cd 2dFFT``
4. Build host executable : ``make``
5. Launch host executable to run benchmarking: ``./2dFFT``

After the host executable finished the benchmarking process it will create a 2dFFT_benchmark_results.csv data file that will contain benchmark results. The benchmark results will include:

- No. of Batches for given test
- Execution time for given test
- The GLFOPS calculated

2D cuFFT Benchmark Options
--------------------------------------------------------
Host executable provides different options while launching benchmark. These options can be used to control what different range of FFTs are benchmarked and also it has options to specify which range of batch sizes to benchmark. The user can also choose if the linear batch size range is used or logarithmic range with options to control the step size. In all the example runs below, the size of 2D FFT is assumed to be square so only once dimension is specified as the size. So all the FFTs of shape NxN are benchmarked.
Following example will explain the usage of benchmarking.

1. ``./2dFFT`` 
	
	- Batch Size range will be **logarithmic**, it will run the benchmark with fixed FFT size range, step size and batch sizes.

2. ``./2dFFT linear``

	- Batch size range will be **linear**, it will run the benchmark with fixed FFT size range, step size and batch sizes.

3. ``./2dFFT max_fft_size max_batch_size``

	- Batch size range will be **logarithmic**, it will run the benchmark with fixed starting FFT size and up to **max_fft_size**, and batch sizes up to **max_batch_size**.	

4. ``./2dFFT linear max_fft_size max_batch_size``

	- Batch size range will be **linear**, it will run the benchmark with fixed starting FFT size up to **max_fft_size**, and batch sizes up to **max_batch_size**.

5. ``./2dFFT starting_fft_size max_fft_size starting_batch_size max_batch_size``

	- Batch size range will be **logarithmic**, it will run the benchmark with starting FFT size **starting_fft_size** and maximum size up to **max_fft_size**, with starting batch size **starting_batch_size** and maximum batch size up to **max_batch_size**

6. ``./2dFFT linear starting_fft_size max_fft_size starting_batch_size max_batch_size``

	- Batch size range will be **linear**, it will run the benchmark with starting FFT size **starting_fft_size** and maximum size up to **max_fft_size**, with starting batch size **starting_batch_size** and maximum batch size up to **max_batch_size**			

7. ``./1dFFT starting_fft_size max_fft_size fft_size_step starting_batch_size max_batch_size batch_size_step``

	- Batch size range will be **logarithmic**, it will run the benchmark with starting FFT size **starting_fft_size** and maximum size up to **max_fft_size** the step on FFT size with be **fft_size_step**, with starting batch size **starting_batch_size** and maximum batch size up to **max_batch_size** and with step on FFT batch size **batch_size_step**		

8. ``./1dFFT linear starting_fft_size max_fft_size fft_size_step starting_batch_size max_batch_size batch_size_step``

	- Batch size range will be **linear**, it will run the benchmark with starting FFT size **starting_fft_size** and maximum size up to **max_fft_size** the step on FFT size with be **fft_size_step**, with starting batch size **starting_batch_size** and maximum batch size up to **max_batch_size** and with step on FFT batch size **batch_size_step**

2D cuFFT Benchmark Results
--------------------------------------------------------------
Following table gives performance resutls for 2D FFT benchmarked using cuFFT library for floating point single precision numbers for various lengths and batch sizes. 

.. csv-table:: 2D cuFFT Benchmark Results for Tesla V100  in Google Cloud
   :file: ../csv_data_files/gpu_bench_2dfft.csv
   :align: left
   :header-rows: 1

GPU Benchmarking Measurement Process and Performance Metrics
------------------------------------------------------------------------------
All the execution time measurements are taken from host side using high resolution software timers. Specifically ``high_resolution_clock`` class is used for taking and storing time samples. The class provides functionality and storage for high resolution time samples. The following code snippet shows how kernel execution time measurement is taken:

.. code-block:: cpp

	#include <chrono>
	high_resolution_clock::time_point t3;
	high_resolution_clock::time_point t4;	
	t3 = high_resolution_clock::now();
	cudaMemcpy(d_inData, h_inData,k_inputDataSizeBytes, cudaMemcpyHostToDevice);
	if (cufftExecC2C(plan, d_inData, d_outData, CUFFT_FORWARD) != CUFFT_SUCCESS)
	{
	    fprintf(stderr, "CUFFT error: ExecC2C Forward failed");
	    return; 
	}
	cudaMemcpy(h_outData, d_outData, k_inputDataSizeBytes,cudaMemcpyDeviceToHost);
	}
	if (cudaDeviceSynchronize() != cudaSuccess)
	{
	    fprintf(stderr, "Cuda error: Failed to synchronize\n");
	    return; 
	}   
	t4 = high_resolution_clock::now();
	duration<double> time_span2 = duration_cast<duration<double>>(t4-t3);
	double exec_time = time_span2.count() / (kernel_iterations * batch_size);


The FLOPS calculation formulas used are the same as used for GPU performance metrics calculations.

.. csv-table:: FLOPS Calculation Formulas ( FFT Complex In:Complex Out)
   :file: ../csv_data_files/flop_formulas.csv
   :align: left
   :header-rows: 1
